@page "/test-generic-component"
@using System.Reflection
@using Blazor.Tools.BlazorBundler.Utilities.Exceptions
@using Microsoft.CodeAnalysis
@using Microsoft.CodeAnalysis.CSharp

<PageTitle>Testing Generic component with Dynamically created Assembly</PageTitle>
@* Example usage with dynamically created instances *@
<MessageDisplay Item="DynamicInstance" />

@code {
    [Parameter]
    public object DynamicInstance { get; set; } = default!;

    protected override async Task OnInitializedAsync()
    {
        // Define the source code for ClassA
        var classASource = @"
using System;

namespace Models
{
    public class ClassA
    {
        public virtual string GetMessage() => ""Hello from ClassA"";
    }
}";

        // Define the source code for ClassB
        var classBSource = @"
using System;
using System.Threading.Tasks;
using Interfaces;

namespace Models
{
    public class ClassB : ClassA, IViewModel<ClassA, IModelExtendedProperties>, IModelExtendedProperties
    {
        public bool IsEditMode { get; set; }

        public override string GetMessage() => ""Hello from ClassB"";

        public async Task<IViewModel<ClassA, IModelExtendedProperties>> SetEditMode(bool isEditMode)
        {
            IsEditMode = isEditMode;
            await Task.CompletedTask;
            return this;
        }
    }
}";

        // Define the source code for the interfaces
        var interfaceSource = @"
using System.Threading.Tasks;

namespace Interfaces
{
    public interface IViewModel<TModel, TIModel>
    {
        Task<IViewModel<TModel, TIModel>> SetEditMode(bool isEditMode);
    }

    public interface IModelExtendedProperties
    {
        bool IsEditMode { get; set; }
    }
}";

        // Compile all sources into a single in-memory assembly
        var combinedAssemblyBytes = EmitAssemblyToMemory("CombinedAssembly", interfaceSource, classASource, classBSource);

        // Load the combined assembly from memory
        var combinedAssembly = Assembly.Load(combinedAssemblyBytes);

        // Get the type of ClassB
        var dynamicType = combinedAssembly.GetType("ClassB")!;
        DynamicInstance = Activator.CreateInstance(dynamicType)!;

        // Set IsEditMode to true and verify the change
        var setEditModeMethod = dynamicType.GetMethod("SetEditMode");
        if (setEditModeMethod != null)
        {
            await (Task)setEditModeMethod.Invoke(DynamicInstance, new object[] { true })!;
        }
    }

    private static byte[] EmitAssemblyToMemory(string assemblyName, params string[] sourceCodes)
    {
        var syntaxTrees = sourceCodes.Select(code => CSharpSyntaxTree.ParseText(code)).ToList();
        var references = new List<MetadataReference>
    {
        MetadataReference.CreateFromFile(typeof(object).Assembly.Location),
        MetadataReference.CreateFromFile(typeof(Task).Assembly.Location),
    };

        var compilation = CSharpCompilation.Create(assemblyName)
            .WithOptions(new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary))
            .AddReferences(references)
            .AddSyntaxTrees(syntaxTrees);

        using var ms = new MemoryStream();
        var result = compilation.Emit(ms);

        if (!result.Success)
        {
            var failures = result.Diagnostics.Where(diagnostic => diagnostic.Severity == DiagnosticSeverity.Error);
            foreach (var diagnostic in failures)
            {
                AppLogger.WriteInfo($"{diagnostic.Id}: {diagnostic.GetMessage()}");
            }
            throw new InvalidOperationException("Compilation failed");
        }

        return ms.ToArray();
    }


}